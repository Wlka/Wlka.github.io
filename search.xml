<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iData实体]]></title>
    <url>%2F2019%2F03%2F08%2FiData%E5%AE%9E%E4%BD%93%2F</url>
    <content type="text"><![CDATA[实体 iData图面上的点、线、面、文字注记、影像等元素分别为iDataPoint、iDataPolyline、iDataPolygon、iDataText、iDataImage，它们都继承自iDataEntity类123456789101112131415161718192021222324252627282930e,entity,point=pid.iDataEntSel('select an entity you want to check: ')#iDataEntSel方法用来选择一个实体，返回三参数，后两个分别是实体以及选定点的坐标if e==pid.iData.eOk: t=entity.type() #实体类型 print(e) print(entity) print(point) if t==pid.iData.IDATAPOINT: print('point') elif t==pid.iData.IDATAPOLYLINE: print('line') elif t==pid.iData.IDATAPOLYGON: print('gon') elif t==pid.iData.IDATATEXT: print('text') elif t==pid.iData.IDATAIMAGE: print('image') else: print("I don't know what is this...") nodes,bulges=entity.getNodes() #取得实体节点 #两个参数的类型都是ListList print('实体由&#123;&#125;部分组成'.format(nodes.size())) for i in range(len(nodes)): print('&#123;&#125;部分包含&#123;&#125;个节点'.format(i+1,len(nodes[i]))) for p in nodes[i]: print(p)else: print('esc') 实体几何1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#创建点实体geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOINT) #获取默认点编码pos=pid.Point3D(250,250,3.14) #给定点坐标entity=pid.iDataPoint(geoCode,pos) #创建一个点实体pid.iDataAppendEntity(entity) #将实体提交到图面pid.CommitEntity(entity,pid.iData.kAppended) #提交到数据库pid.iDataRegen(None,True) #刷新图面-----------------------------------------------------------#创建线实体arrNodes=pid.Point3DListList() #节点列表arrBulges=pid.DoubleListList() #凸度列表，如不需要留空即可posList=pid.Point3DList() #坐标列表posList.append(pid.Point3D(0,0,0))posList.append(pid.Point3D(1000,250,0))posList.append(pid.Point3D(500,1000,0))arrNodes.append(posList)geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOLYLINE)entity=pid.iDataPolyline(geoCode,arrNodes,arrBulges)pid.iDataAppendEntity(entity) #实体提交到图面pid.CommitEntity(entity,pid.iData.kAppended) #实体提交到数据库pid.iDataRegen(None,True) #刷新图面-----------------------------------------------------------#创建面实体arrNodes=pid.Point3DListList() #节点列表arrBulges=pid.DoubleListList() #凸度列表，如不需要留空即可posList=pid.Point3DList() #坐标列表#构建多边形需要闭合posList.append(pid.Point3D(0,0,0))posList.append(pid.Point3D(250,0,0))posList.append(pid.Point3D(0,250,0))posList.append(pid.Point3D(0,0,0))arrNodes.append(posList)#获取默认面编码，并创建实体geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOLYGON)entity=pid.iDataPolygon(geoCode,arrNodes,arrBulges)pid.iDataAppendEntity(entity) #实体提交到图面pid.CommitEntity(entity,pid.iData.kAppended) #实体提交到数据库pid.iDataRegen(None,True) #刷新图面 实体凸度12345678910111213141516171819202122232425#创建一个圆arrNodes=pid.Point3DListList() #节点列表arrBulges=pid.DoubleListList() #凸度列表，如不需要留空即可posList=pid.Point3DList() #坐标列表posList.append(pid.Point3D(0,0,0))posList.append(pid.Point3D(300,0,0))posList.append(pid.Point3D(0,0,0))arrNodes.append(posList)#这里使用凸度控制弧线，凸度=tan(圆心角)/4bList=pid.DoubleList()#bList.fromList([1,1,0])bList.append(1)bList.append(1)bList.append(0)arrBulges.append(bList)#获取默认线编码，并创建实体geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOLYLINE)entity=pid.iDataPolygon(geoCode,arrNodes,arrBulges)pid.iDataAppendEntity(entity) #实体提交到图面pid.CommitEntity(entity,pid.iData.kAppended) #实体提交到数据库pid.iDataRegen(None,True) #刷新图面 实体属性123456789101112131415161718192021222324e,entity,point=pid.iDataEntSel('Select an entity')if e==pid.iData.eOk: propertys=entity.getXDataAll() #实体所有扩展属性 bz=entity.getXData('WYBZ') #取出特定扩展属性 if bz.type()==pid.Variant.Type_Invalid: print('选中实体不存在WYBZ字段') print('原始值: '+entity.getXData('GD').toString()) bz_new=pid.Variant() bz_new.setValue('设置新值') entity.setXData('WYBZ',bz_new) #设置新值 print('修改值: '+entity.getXData('GD').toString()) entity.setSelected(True) #让选择的实体显示出来 pid.COmmitEntity(entity,pid.iData.kModified) #修改提交到数据库 pid.iDataRegen(None,True) #刷新图面 print('The selected entity has &#123;&#125; propertys'.format(len(propertys))) for k,v in propertys: print(k,': ',v.toString()) p=propertys['CODE'] print(p) #print(propertys['CODE'].toString()) #同样为取属性else: print('esc') 在iData中增删改了实体都需要提交才能生效，分别是提交到图面(按需调用iDataAppendEntity、iDataEntDel)、提交到数据库(调用Commit方法)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#点实体实例count=100entityList=pid.iDataEntityList()geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOINT)for i in range(count): for j in range(count): pos=pid.Point3D(i*10,j*10,0) point=pid.iDataPoint(geoCode,pos) entityList.append(point)#提交实体到图面err=pid.iDataAppendEntity(entityList)if err==pid.iData.eOk: print('添加了&#123;&#125;个实体到屏幕'.format(entityList.size()))err=pid.CommitEntity(entityList,pid.iData.kAppended)if err==pid.iData.eOk: print('添加了&#123;&#125;个实体到数据库'.format(entityList.size()))pid.iDataRegen(None,True)#线实体实例arrNodes=pid.Point3DListList()arrBulges=pid.DoubleListList()#曲线第一部分，绘制正弦曲线posList=pid.Point3DList()for i in range(0,628,2): y=100*math.sin(i/100.0) pos=pid.Point3D(i,y,0) posList.append(pos)arrNodes.append(posList)#曲线第一部分，绘制余弦曲线posList=pid.Point3DList()for i in range(0,628,2): y=100*math.cos(i/100.0) pos=pid.Point3D(i,y,0) posList.append(pos)arrNodes.append(posList)geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOLYLINE)entityList=pid.iDataPolyline(geoCode,arrNodes,arrBulges)#提交实体到图面err=pid.iDataAppendEntity(entityList)err=pid.CommitEntity(entityList,pid.iData.kAppended)#添加说明文字geoCode=pid.getDeFaultGeoCode(pid.iData.IDATATEXT)entity=pid.iDataText(geoCode,pid.Point3D(10,-10,0),'y=sin(x)') #设置文字注记的位置entity.setFamily('微软雅黑') #设置字体entity.setPointSizeF(18*4.0654228942042955) #设置字高(需要乘以一个固定比例)entity.setItalic(True)pid.iDataAppendEntity(entity)pid.CommitEntity(entity,pid.iData.kAppended)pid.iDataRegen(None,True)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mySQL安装小记]]></title>
    <url>%2F2019%2F03%2F07%2FmySQL%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天搭建了mySQL环境，想着准备学一下怎么用QT操作数据库，期间遇到了些小问题，现在来记录一下 下载安装 首先我们先去mySQL官网下载对应的版本，这里我们选择社区版，然后选择一个路径把压缩包解压，在路径目录下新建一个my.ini配置文件，记事本打开后输入以下内容1234567891011121314151617[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\web\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\web\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 配置 接下来，我们开始配置环境，管理员身份打开cmd，并切换到你刚才解压文件的路径下，按步骤执行以下操作 1234567891011mysqld --initialize --console #初始化数据库#命令执行完毕后，会输出root的初始密码2018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: APWCY5ws&amp;hjQ#这里的APWCY5ws&amp;hjQ就是密码，之后的登录操作会用到mysqld install #安装net start mysql #启动服务mysql -h 主机名 -u 用户名 -p #h为要登录的主机名，默认为localhost，可忽略；u为用户名；p为密码#输入命令后回车，会提示你输入密码，这时候就输入上面的默认root密码 到这里还没有结束，需要修改默认的root密码 1mysql&gt; alter user &apos;用户名&apos;@&apos;主机名&apos; identified by &apos;新密码&apos;; #要修改root密码，这里的主机名填localhost 到这里基本的配置就完毕了，mySQL有不少图形化窗口软件支持，例如Navicat这里就不赘述了，结合需要去使用，注意，在条件允许的情况下，记得支持正版哦~]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++类中重载运算符]]></title>
    <url>%2F2019%2F03%2F01%2Fcpp%E7%B1%BB%E4%B8%AD%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[C++中重载操作符时，对于+-*/等二元运算符，如果声明为非友元类，系统会自动生成一个this指针 1234567891011121314151617181920//这里有一个matrix类class Array&#123;public: Array()&#123;&#125;; Array(int r,int c)&#123;...&#125; Array(const Array &amp;a)&#123;...&#125; ~Array()&#123;...&#125; //声明为非友元 Array operator*(Array &amp;a1); //此时会自动生成一个this指针 //声明为友元 friend Array operator*(Array &amp;a1,Array &amp;a2);private: int row; int column; double **arr;&#125; Effective C++中的条款10提到: 令operator=返回一个reference to *this 在vs中，有一个错误：C2678 二进制“[”: 没有找到接受“const xxx”类型的左操作数的运算符，出现这种错误的情况一般是在非const函数中使用了const变量]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用github+Hexo搭建个人博客]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言github是一个面向开源及私有软件项目的托管平台，hexo是一个”快速、简洁且高效的博客框架”，这里我们利用github+hexo来搭建一个自己的博客 开始 首先，我们要注册一个github账号，然后创建一个仓库创建后新建一个index.html文件，作为博客的根目录 然后，下载安装node.js，下载安装git，安装完成后还需要做一些git的配置，网上有不少教程，这里就不再赘述了 以上步骤就绪后,打开命令行，cd到你要放置博客文件的目录，输入以下命令12345npm install hexo-cli -g #等待下载安装完毕hexo init yourBlogName #你的路径下会自动生成一个你指定名称的文件夹cd yourBlogNamenpm install #继续完成安装hexo s #启动hexo服务 这时候打开你的浏览器，输入localhost:端口号你就会发现搭建的博客出来啦！ 别高兴的这么快现在我们只是在本地把博客构建出来而已，还需要进一步配置才能把博客部署到你的github仓库中，下面继续来看一下 使用vscode把整个博客文件夹打开(这里随便大家用哪个编辑器都可以)，打开_confid.yml文件这里的url按这个格式填这里把type改为git，同时加入repo和branch，分别填刚创建的仓库的地址和分支1npm install hexo-deployer-git --save #这里是为了发布到git 最后我们要部署到github上，需要用到deploy命令12hexo g #生成hexo d #部署 在部署前我们可以先在本地预览1hexo s -p 端口号 #这里可指定启动服务的端口 到这里为止，基本就完成了如果你觉得默认的主题太丑，这里是你一个很好的选择，看到喜欢的主题，去github上下载源码，放到博客的themes文件夹下，修改_config.yml文件的theme选项，重新构建，你就会发现博客的主题变成你想要的那个啦！]]></content>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iData常用基本数据类型]]></title>
    <url>%2F2019%2F02%2F24%2FiData%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[DoubleList– iData的浮点数数组 1234import PyiData as pid #以下代码都用pid代替ls=pid.DoubleList()ls.append(12) #添加数据ls.size() #获取数据数量 String– iData的字符串，默认编码为UTF-8 1234567891011str=pid.String() #设置str为PyiData中的String类型str.setValue('abc') #设置str的数据，也可以在上一句中直接设置可通过setValueGBK()方法设置GBK编码的数据example:e=pid.iDataInitGet(1,'Y N I')e,s=pid.iDataGetString('确认[Y]/取消[N]/忽略[I]/请输入选择: ')if e==pid.iData.eOk or e==pid.iData.eKWord: #eOk指按下回车，eKWord指按下按键 print(s)else: print('用户放弃选择') Variant– iData的可变数据类型，可通过setValue来设置不同的类型数据 1234v=pid.Variant()v.setValue()#设置数据后，可通过对应的to方法显示对象v的数据v.toString() v.toDouble() v.toPoint3D()... Point3D Point3DList Point3DListList– 点的三维坐标、坐标点数组(一维)、坐标点数组的集合(二维) 1234567891011121314151617181920212223p=pid.Point3D(100,100,0)p.setXYZ(100,100,0)p.x() p.y() p.z() #分别获取对应的xyz坐标#可以进行加操作：p3=p1+p2#可以进行比较操作：p1==p2p1=pid.Point3DList()for i in range(5): p=pid.Point3D(100,100,0) p1.append(p) #只能传入对象p2=pid.point3DListList()p2.append(p1)Point基本用法example:e,point1=pid.iDataGetPoint('获取图面上一个点:') #e为状态，point1为选定点的坐标e,point2=pid.iDataGetPoint2(point1,'获取图面上第二个点:') #e为状态，point2为选定点的坐标e,point3=pid.iDataGetCorner(point1,'在图面上拉框选择第二个点:') #e为状态，point3为选定点的坐标if point3.x()&lt;point1.x() print('右拉框(第一个点在第二点右边)')else print('左拉框(第一个点在第二点左边)') Rect– 矩形 1234567891011121314r=pid.Rect(0,0,100,200) #x起点 y起点 宽 高r.xp() r.yp() r.w() r.h()r.center() #中心点坐标r.bottomRight() #右下角点坐标p=pid.Point3D(50,50,0)print(r.containsPoint(p)) #查看点p是否在矩形r内r2=pid.Rect(0,0,20,50)print(r.contains(p)) #查看矩形r2是否在矩形r内print(r.intersects(r2)) #查看矩形r和r2是否相交r2.setTopLeft(0,0) #设置左上角点r2.setSize(100,100) #设置尺寸 Color– 颜色 12345c=pid.Color(255,255,0,255) #R G B Ac.r c.g c.b c.ac1=pid.backgroundColor() #获取当前背景色pid.setBackgroundColor(c) #设置背景色,只接收对象c0=pid.iData_GetColor(0) #获取索引色]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于const]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%85%B3%E4%BA%8Econst%2F</url>
    <content type="text"><![CDATA[const在星号左边，例如const int p，不可以通过p来修改指向位置的数据,但是可以修改p指向的地址 1234int a=5,b=0;const int *p=&amp;a;*p=10; //not allowed*p=&amp;b; //allowed const在星号右边，例如int const q,可以通过修改q来修改指向位置的数据，但是不可以修改q指向的地址 1234int a=5,b=0;int * const q=&amp;a;*q=10; //allowed*q=&amp;b; //not allowed const在函数后，该函数为const成员函数，函数不能修改数据成员，也不能调用非const函数 const在函数前，修改该函数的返回值，函数返回值(指针)的内容不能被修改，只能被赋给同类型的const指针]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
</search>
