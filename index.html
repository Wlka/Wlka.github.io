<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="Welcome to my blog">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Wlka</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline autoplay loop muted data-autoplay poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Wlka</a></h1>
      <p>本以为是物是人非，不曾想是面目全非</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Wlka"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        <article id="post-从文件中恢复二叉树" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/06/从文件中恢复二叉树/">从文件中恢复二叉树</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/06/从文件中恢复二叉树/" class="article-date">
  <time datetime="2019-08-06T08:04:20.000Z" itemprop="datePublished">2019-08-06</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h3 id="假设有一个需求，将二叉树存入文件，并想办法从文件中读取出来，然后重构这棵二叉树"><a href="#假设有一个需求，将二叉树存入文件，并想办法从文件中读取出来，然后重构这棵二叉树" class="headerlink" title="假设有一个需求，将二叉树存入文件，并想办法从文件中读取出来，然后重构这棵二叉树"></a>假设有一个需求，将二叉树存入文件，并想办法从文件中读取出来，然后重构这棵二叉树</h3><p>首先，要想办法把二叉树从文件数据中重构，那么一定要想办法找出合适的遍历算法将二叉树存入到文件</p>
<p>我们知道二叉树有四种遍历：前序、中序、后序、层次遍历，但是这里面只有一种遍历算法符合我们的要求</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">先假设我们有一个这样的二叉树</span></span><br><span class="line"><span class="comment">	30</span></span><br><span class="line"><span class="comment">   /  \</span></span><br><span class="line"><span class="comment">  20  40</span></span><br><span class="line"><span class="comment"> /	 /  \</span></span><br><span class="line"><span class="comment">10  35  50</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">它的中序遍历和后序遍历父节点都不在叶子节点前先输出，这样我么你无法确定父节点和它孩子的位置</span></span><br><span class="line"><span class="comment">但是前序遍历则没有这个问题，父节点总是在叶子节点前先输出，我们先构造父节点，然后确定孩子节点</span></span><br><span class="line"><span class="comment">但是在操作时，需要记录空节点，否则处理上会有问题</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readBST</span><span class="params">(struct node *&amp;root, ifstream &amp;fin)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    fin &gt;&gt; val;	<span class="comment">//先读取根节点数据</span></span><br><span class="line">    readBSTHelper(INT_MIN, INT_MAX, val, root, fin);<span class="comment">//传入父节点数据，递归调用函数来确定左右孩子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readBSTHelper</span><span class="params">(<span class="keyword">int</span> min,<span class="keyword">int</span> max,<span class="keyword">int</span> &amp;insertVal,class node *&amp;p,ifstream &amp;fin)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (insertVal &gt; min &amp;&amp; insertVal &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        p = newNode(insertVal);	<span class="comment">//构造父节点</span></span><br><span class="line">        <span class="keyword">while</span>(fin &gt;&gt; insertVal &amp;&amp; insertVal==<span class="string">"#"</span>) fin&gt;&gt;insertVal;<span class="comment">//继续读取数据，并跳过空节点</span></span><br><span class="line">        readBSTHelper(min, val, insertVal, p-&gt;left, fin);</span><br><span class="line">        readBSTHelper(val, max, insertVal, p-&gt;right, fin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/08/06/从文件中恢复二叉树/" data-id="cjyzjijpt000bh8w1bbsvy50s" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-BFPRT算法" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/06/BFPRT算法/">BFPRT算法</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/06/BFPRT算法/" class="article-date">
  <time datetime="2019-08-06T08:03:55.000Z" itemprop="datePublished">2019-08-06</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>topK是一道经典面试题，就是在一堆数里找出第K大的数字</p>
<p>这道题有很多解法，这里介绍一下BFPRT算法</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BFPRT算法，又称为中位数的中位数算法，它的最坏时间复杂度为$O(n)$，它是由Blum、Floyd、Pratt、Rivest、Tarjan提出。该算法的思想是修改快速选择算法的主元选取方法，提高算法在最坏情况下的时间复杂度</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们知道快速排序每次从序列中选取一个数作为基准，将序列中比基准大的数放在基准右边，比基准小的放在基准左边，一趟快速排序成为partition，我们无法确保每次划分得很均匀，所以最坏情况下不能保证时间复杂度为$O(n log n)$，而是$O(n^2)$。在BFPRT算法中，仅仅是改变了每趟快速排序的pivot值的选取，即每次将序列划分为5份，挑选中位数作为pivot，在每份里面进行插入排序</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>$T(n)≤T(n/5)+T(7n/10)+c*n$</p>
<p>设$T(n)=t*n$，其中t可能是一个常数，也可能是关于n的函数，代入上式</p>
<p>$t<em>n≤t</em>n/5+t<em>7n/10+c</em>n $ -&gt; $t≤10c$</p>
<p>c是常数，所以t也是常数，即$T(n)≤10c*n$，所以$T(n)=O(n)$</p>
<hr>
<p>那么为什么是5呢？首先偶数排数，对于奇数来说中位数的选取更容易，如果选取7、9或是更大，插入排序时耗时增加，有些得不偿失，而选择3时，有$T(n)=T(n/3)+T(2n/3)+c*n$，其操作元素个数还是n</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>将n个元素划分为$n/5$组，每组5个</li>
<li>寻找着$n/5$个组中每组的中位数，可以用插入排序</li>
<li>对步骤2中的$n/5$个中位数重复步骤1、2，递归下去知道剩下一个数字</li>
<li>最终剩下的数字即为pivot，大于它的数放左边，小于小于它的放右边</li>
<li>判断pivot位置与k的大小，有选择的对左边或右边递归</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l+<span class="number">1</span>; i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=a[i];</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;l &amp;&amp; a[j<span class="number">-1</span>]&gt;t)</span><br><span class="line">            &#123;</span><br><span class="line">                a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//寻找中位数的中位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=l; i&lt;r<span class="number">-5</span>; i+=<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertSort(a,i,i+<span class="number">4</span>);</span><br><span class="line">        n=i-l;</span><br><span class="line">        swap(a[l+n/<span class="number">5</span>],a[i+<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//处理剩余元素</span></span><br><span class="line">    <span class="keyword">int</span> num=r-i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertSort(a,i,i+num<span class="number">-1</span>);</span><br><span class="line">        n=i-l;</span><br><span class="line">        swap(a[l+n/<span class="number">5</span>],a[i+num/<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    n/=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==l) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> FindMid(a,l,l+n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//进行划分过程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(a[p],a[l]);</span><br><span class="line">    <span class="keyword">int</span> i=l;</span><br><span class="line">    <span class="keyword">int</span> j=r;</span><br><span class="line">    <span class="keyword">int</span> pivot=a[l];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;=pivot &amp;&amp; i&lt;j)</span><br><span class="line">            j--;</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=pivot &amp;&amp; i&lt;j)</span><br><span class="line">            i++;</span><br><span class="line">        a[j]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i]=pivot;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFPRT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=FindMid(a,l,r);    <span class="comment">//寻找中位数的中位数</span></span><br><span class="line">    <span class="keyword">int</span> i=Partion(a,l,r,p);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> m=i-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==k) <span class="keyword">return</span> a[i];</span><br><span class="line">    <span class="keyword">if</span>(m&gt;k)  <span class="keyword">return</span> BFPRT(a,l,i<span class="number">-1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> BFPRT(a,i+<span class="number">1</span>,r,k-m);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;    <span class="comment">//数据数量和K值</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:a) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n第"</span>&lt;&lt;k&lt;&lt;<span class="string">"大数字: "</span>&lt;&lt;BFPRT(a,<span class="number">0</span>,n<span class="number">-1</span>,k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/08/06/BFPRT算法/" data-id="cjyzjijnn0000h8w1tr05gwoe" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-vim使用命令" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/06/vim使用命令/">vim使用命令</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/06/vim使用命令/" class="article-date">
  <time datetime="2019-08-06T08:03:32.000Z" itemprop="datePublished">2019-08-06</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h3 id="vim基本操作"><a href="#vim基本操作" class="headerlink" title="vim基本操作"></a>vim基本操作</h3><blockquote>
<p>编辑模式  </p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i/I</td>
<td style="text-align:center">从光标所在位置插入/在目前所在行第一个非空格符处插入</td>
</tr>
<tr>
<td style="text-align:center">a/A</td>
<td style="text-align:center">从光标所在下一个字符处插入/在目前所在行最后一个字符处插入</td>
</tr>
<tr>
<td style="text-align:center">o/O</td>
<td style="text-align:center">从光标所在下一行输入新行/从光标所在上一行输入新行</td>
</tr>
<tr>
<td style="text-align:center">r/R</td>
<td style="text-align:center">只取代光标所在字符一次/一直取代光标所在文字直到按下Esc</td>
</tr>
</tbody>
</table>
<blockquote>
<p>指令行模式</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:w</td>
<td style="text-align:center">保存</td>
</tr>
<tr>
<td style="text-align:center">:w!</td>
<td style="text-align:center">强制写入只读文件，但是还是跟权限有关</td>
</tr>
<tr>
<td style="text-align:center">:q</td>
<td style="text-align:center">退出vim</td>
</tr>
<tr>
<td style="text-align:center">:q!</td>
<td style="text-align:center">退出vim但是不修改文件</td>
</tr>
<tr>
<td style="text-align:center">:wq</td>
<td style="text-align:center">保存退出</td>
</tr>
<tr>
<td style="text-align:center">:wq!</td>
<td style="text-align:center">强制保存退出</td>
</tr>
<tr>
<td style="text-align:center">ZZ</td>
<td style="text-align:center">文件被修改则保存后离开，否则直接离开</td>
</tr>
<tr>
<td style="text-align:center">:w filename</td>
<td style="text-align:center">将数据保存到另一个文件，相当于另存为</td>
</tr>
<tr>
<td style="text-align:center">:r filename</td>
<td style="text-align:center">将filename的数据加到编辑数据的光标所在行后面</td>
</tr>
<tr>
<td style="text-align:center">:n1,n2 w filename</td>
<td style="text-align:center">将n1到n2行的内容保存到filename文件中</td>
</tr>
<tr>
<td style="text-align:center">:!command</td>
<td style="text-align:center">暂时离开vim到指令行模式执行command的显示结果</td>
</tr>
</tbody>
</table>
<blockquote>
<p>vim环境变更</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:set nu</td>
<td style="text-align:center">在每行前显示行号</td>
</tr>
<tr>
<td style="text-align:center">:set nonu</td>
<td style="text-align:center">取消显示行号</td>
</tr>
</tbody>
</table>
<blockquote>
<p>一般模式</p>
</blockquote>
<ul>
<li>移动光标</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">hjkl</td>
<td style="text-align:center">光标左下上右移动一个字符，在前面搭配数字可以实现快速移动，方向键效果一样</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+f</td>
<td style="text-align:center">效果同Page Down</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b</td>
<td style="text-align:center">效果同Page Up</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+d</td>
<td style="text-align:center">向下移动半页</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+u</td>
<td style="text-align:center">向上移动半页</td>
</tr>
<tr>
<td style="text-align:center">+/-</td>
<td style="text-align:center">光标移动到非空格符下/上一行</td>
</tr>
<tr>
<td style="text-align:center">n+space</td>
<td style="text-align:center">光标向右移动这行的n个字符</td>
</tr>
<tr>
<td style="text-align:center">n+Enter</td>
<td style="text-align:center">光标向下移动n行</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">效果同Home</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">效果同End</td>
</tr>
<tr>
<td style="text-align:center">H/L</td>
<td style="text-align:center">光标移动到屏幕最上/下方那行的第一个字符</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">光标移动到屏幕中央那行第一个字符</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">移动到这个文件最后一行</td>
</tr>
<tr>
<td style="text-align:center">nG</td>
<td style="text-align:center">移动到这个文件第n行</td>
</tr>
<tr>
<td style="text-align:center">gg</td>
<td style="text-align:center">移动到文件第一行</td>
</tr>
</tbody>
</table>
<ul>
<li>搜索替换</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/word</td>
<td style="text-align:center">向光标之下寻找一个名为word的字符串</td>
</tr>
<tr>
<td style="text-align:center">?word</td>
<td style="text-align:center">向光标之上寻找一个名为word的字符串</td>
</tr>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">重复一次前一个搜索动作</td>
</tr>
<tr>
<td style="text-align:center">N</td>
<td style="text-align:center">反向重复一次前一个搜索动作</td>
</tr>
<tr>
<td style="text-align:center">:n1,n2s/word1/word2/g[c]</td>
<td style="text-align:center">在n1到n2行之间用word2取代word1，最后一个c是可选项，表示取代前提示用户确认</td>
</tr>
<tr>
<td style="text-align:center">:1,$s/word1/word2/g</td>
<td style="text-align:center">从第一行到最后一行将word1替换为word2</td>
</tr>
<tr>
<td style="text-align:center">:%s/word1/word2/g</td>
<td style="text-align:center">效果同上</td>
</tr>
</tbody>
</table>
<ul>
<li>删除/复制/粘贴</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x/X</td>
<td style="text-align:center">向后/前删除一个字符，效果同delete和backspace</td>
</tr>
<tr>
<td style="text-align:center">nx/nX</td>
<td style="text-align:center">连续向后/前删除n个字符</td>
</tr>
<tr>
<td style="text-align:center">dd</td>
<td style="text-align:center">删除光标所在的整行</td>
</tr>
<tr>
<td style="text-align:center">ndd</td>
<td style="text-align:center">删除光标所在的向下n行</td>
</tr>
<tr>
<td style="text-align:center">d1G</td>
<td style="text-align:center">删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td style="text-align:center">dG</td>
<td style="text-align:center">删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td style="text-align:center">d$</td>
<td style="text-align:center">删除光标所在行到该行最后一个字符</td>
</tr>
<tr>
<td style="text-align:center">d0</td>
<td style="text-align:center">删除光标所在行到该行最前面一个字符</td>
</tr>
<tr>
<td style="text-align:center">yy</td>
<td style="text-align:center">复制光标所在行</td>
</tr>
<tr>
<td style="text-align:center">nyy</td>
<td style="text-align:center">复制光标所在的向下n行</td>
</tr>
<tr>
<td style="text-align:center">y1G</td>
<td style="text-align:center">复制光标所在到第一行的所有数据</td>
</tr>
<tr>
<td style="text-align:center">yG</td>
<td style="text-align:center">复制光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td style="text-align:center">y$</td>
<td style="text-align:center">复制光标所在行到该行行尾的所有数据</td>
</tr>
<tr>
<td style="text-align:center">y0</td>
<td style="text-align:center">复制光标所在行到该行行首的所有数据</td>
</tr>
<tr>
<td style="text-align:center">p/P</td>
<td style="text-align:center">将复制的数据粘贴到光标下/上一行</td>
</tr>
<tr>
<td style="text-align:center">J</td>
<td style="text-align:center">将光标所在行与下一行数据结合成一行</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">重复删除多个数据，例如10ck为向上删除10行</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:center">复原前一个动作，类似撤销</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+r</td>
<td style="text-align:center">重做上一个动作，类似取消撤销</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">重复上一个动作</td>
</tr>
</tbody>
</table>
<blockquote>
<p>one more thing</p>
</blockquote>
<ul>
<li>Ctrl+v可以进入块选择模式</li>
<li>:n1,n2s/^/注释符/g可以快速在多行行首添加注释</li>
<li>:n1,n2s/^注释符//g可以快速取消多行注释</li>
</ul>
<blockquote>
<p>打开多文件</p>
</blockquote>
<ul>
<li>vim file1 file2 file3</li>
<li>:n #跳到下一个文件</li>
<li>:n filename #跳到指定文件</li>
<li>:e# #回到刚才编辑的文件</li>
</ul>
<blockquote>
<p>打开多窗口</p>
</blockquote>
<ul>
<li>vim -p file1 file2 file3 #标签页形式打开多窗口</li>
<li>vim -o[-O] file1 file2 file3 #水平/垂直打开多窗口</li>
<li>vim -d[diff] file1 file2 file3 #垂直打开多窗口，并且进行比较</li>
</ul>
<blockquote>
<p>关闭窗口</p>
</blockquote>
<ul>
<li>:q/:close #关闭当前窗口</li>
<li>:only #保留当前窗口，关闭其他所有窗口</li>
<li>:qall/qa #退出所有窗口</li>
<li>:wall #保存所有窗口</li>
</ul>
<blockquote>
<p>窗口切换</p>
</blockquote>
<ul>
<li>:Ctrl+w+j/k上下切换，也可以Ctrl+w+w一次切换窗口</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/08/06/vim使用命令/" data-id="cjyzjijpr0009h8w17jav3fjo" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vim/">vim</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-排序算法" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/04/排序算法/">排序算法</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/04/排序算法/" class="article-date">
  <time datetime="2019-08-04T05:56:57.000Z" itemprop="datePublished">2019-08-04</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h3 id="几个排序算法的实现与复杂度分析"><a href="#几个排序算法的实现与复杂度分析" class="headerlink" title="几个排序算法的实现与复杂度分析"></a>几个排序算法的实现与复杂度分析</h3><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>每次从左到右两两比较，将大的交换到后面，每次确保前M个元素最大值移到最右边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec.size()-i<span class="number">-1</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[j]&gt;vec[j+<span class="number">1</span>]) swap(vec[j],vec[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(rand()%<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    bubble_sort(vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：重复执行冒泡n次，每次进行n次比较，时间复杂度为$O(n^2)$，空间复杂度为$O(n)$</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>从左到右，把选出的数和前面的数比较，找到最适合它的位置放入，使得前面部分有序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[j]&lt;vec[j<span class="number">-1</span>]) swap(vec[j],vec[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(rand()%<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    insertion_sort(vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：要选择n次，插入时最坏情况下要比较n次，时间复杂度为$O(n^2)$，空间复杂度为$O(n)$</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次都从乱序数组中找到最值，放在数组的一端，最终使得数组有序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;vec.size();++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[j]&lt;vec[min]) min=j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(vec[min],vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(rand()%<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    selection_sort(vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：每次都要找最值，最坏情况下要比较n次，过程执行了n次，时间复杂度为$O(n^2)$，空间复杂度为$O(n)$</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>可以看作是插入排序优化版，以发明者的名字命名，另一个名字是”递减增量排序算法”；插入排序对几乎已排好序数据操作时，可以达到线性排序的效率，但由于每次只能移动一位，所以相对低效，希尔排序将数据分为几个子数组进行排序，最后一步才是普通的插入排序，此时数据已经几乎有序，所以最后一步较快</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap=<span class="number">1</span>;  <span class="comment">//把步长先设为1</span></span><br><span class="line">    <span class="keyword">while</span>(gap&lt;vec.size()/<span class="number">3</span>) gap=gap*<span class="number">3</span>+<span class="number">1</span>;    <span class="comment">//把数组分为3部分进行排序</span></span><br><span class="line">    <span class="keyword">while</span>(gap&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;vec.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=gap&amp;&amp;vec[j]&lt;vec[j-gap];j-=gap)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(vec[j],vec[j-gap]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap=gap/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(rand()%<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    shell_sort(vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：希尔排序的时间复杂度受步长的影响，设N为数组长度，K为当前增量，当$K=2^x$时，时间复杂度为$O(n^2)$；当$K=3x+1$时，时间复杂度为$O(n^{3/2})$，Mark Allen Weiss指出，最好的增量序列是Sedgewick提出的 (1, 5, 19, 41, 109,…)，该序列的项来自 $9 <em> 4^i - 9 </em> 2^i + 1$ 和 $4^i - 3 * 2^i + 1$ 这两个算式</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分治法，把一个数组打散成小数组，再把小数组拼凑后进行排序，知道最后数组有序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_vec</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmpVec,<span class="keyword">int</span> start,<span class="keyword">int</span> middle,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=start;s&lt;=end;++s) tmpVec[s]=vec[s];</span><br><span class="line">    <span class="keyword">int</span> left=start;</span><br><span class="line">    <span class="keyword">int</span> right=middle+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=start;k&lt;=end;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;middle) vec[k]=tmpVec[right++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right&gt;end) vec[k]=tmpVec[left++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tmpVec[right]&lt;tmpVec[left]) vec[k]=tmpVec[right++];</span><br><span class="line">        <span class="keyword">else</span> vec[k]=tmpVec[left++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmpVec,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> middle=start+(end-start)/<span class="number">2</span>;</span><br><span class="line">    merge_sort(vec,tmpVec,start,middle);</span><br><span class="line">    merge_sort(vec,tmpVec,middle+<span class="number">1</span>,end);</span><br><span class="line"></span><br><span class="line">    merge_vec(vec,tmpVec,start,middle,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmpVec(vec.size(),<span class="number">0</span>);</span><br><span class="line">    merge_sort(vec,tmpVec,<span class="number">0</span>,vec.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(rand()%<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    merge_sort(vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：在合并数组操作中只有一次循环，复杂度为$O(n)$，分解数组是对半切割，复杂度为$O(log n)$，所以总体时间复杂度为$O(nlog n)$，由于使用到了额外的空间来存放临时数组，所以空间复杂度为$O(n)$</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>分治法，选择一个基准数，把比它小的数放在它左边，比它大的数放在它右边，然后对左右两部分进行同样的操作，直到整个数组有序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = vec[low];</span><br><span class="line">    <span class="keyword">int</span> i=low;</span><br><span class="line">    <span class="keyword">while</span> (low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要先移动右边</span></span><br><span class="line">        <span class="keyword">while</span> (vec[high] &gt; pivot &amp;&amp; low &lt; high) --high;</span><br><span class="line">        <span class="keyword">while</span> (vec[low] &lt;= pivot &amp;&amp; low &lt; high) ++low;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) swap(vec[low],vec[high]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(vec[i],vec[low]);</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> middle=partition(vec,low,high);</span><br><span class="line">    quick_sort(vec,low,middle<span class="number">-1</span>);</span><br><span class="line">    quick_sort(vec,middle+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec.size()&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    quick_sort(vec,<span class="number">0</span>,vec.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(rand()%<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    quick_sort(vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：快速排序时间复杂度为$O(nlog n)$，空间复杂度为$O(1)$，但这是建立在每次切分都能把数组分为两半的前提下，极端情况下，时间复杂度会退化成$O(n^2)$，当然这概率也比较低</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆其实是一颗完全二叉树，分为大顶堆和小顶堆，实际上可以用一个一维数组表示，下标公式如下：</p>
<ul>
<li>$i$节点的父节点$parent(i)=floor((i-1)/2)$</li>
<li>$i$节点的左子节点$left(i)=2i+1$</li>
<li>$i$节点的右子节点$right(i)=2i+2$</li>
</ul>
<p>步骤：</p>
<ol>
<li>构造大顶堆(Build Max Heap)：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到根节点，重复执行到最后一个元素</li>
<li>大顶堆调整(Max Heapify)：调整大顶堆，将根节点移除后重新整理堆，即让根节点和最大一个节点交换，然后把堆看做$n-1$长度，将当前根节点逐步移动到其应该在的位置</li>
<li>堆排序(HeapSort)：重复执行2，知道所有根节点都被移除</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = vec.size();</span><br><span class="line">    buildHeap(vec,length);	<span class="comment">//构建堆</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- )</span><br><span class="line">    &#123;</span><br><span class="line">        swap(vec[<span class="number">0</span>],vec[i]);	<span class="comment">//将堆顶元素与末位元素调换</span></span><br><span class="line">        size--;	<span class="comment">//数组长度-1 隐藏堆尾元素</span></span><br><span class="line">        sink(vec,<span class="number">0</span>,size);	<span class="comment">//将堆顶元素下沉 目的是将最大的元素浮到堆顶来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(vectror&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        sink(vec,i,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下沉调整</span></span><br><span class="line"><span class="comment"> * @param arr 数组</span></span><br><span class="line"><span class="comment"> * @param index 调整位置</span></span><br><span class="line"><span class="comment"> * @param length 数组范围</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec,<span class="keyword">int</span> index,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftChild = <span class="number">2</span> * index + <span class="number">1</span>;	<span class="comment">//左子节点下标</span></span><br><span class="line">    <span class="keyword">int</span> rightChild = <span class="number">2</span> * index + <span class="number">2</span>;	<span class="comment">//右子节点下标</span></span><br><span class="line">    <span class="keyword">int</span> present = index;	<span class="comment">//要调整的节点下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉左边</span></span><br><span class="line">    <span class="keyword">if</span> (leftChild &lt; size &amp;&amp; vec[leftChild] &gt; vec[present])</span><br><span class="line">        present = leftChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉右边</span></span><br><span class="line">    <span class="keyword">if</span> (rightChild &lt; length &amp;&amp; vec[rightChild] &gt; vec[present])</span><br><span class="line">        present = rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果下标不相等 证明调换过了</span></span><br><span class="line">    <span class="keyword">if</span> (present != index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交换值</span></span><br><span class="line">        swap(vec[index],vec[present]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//继续下沉</span></span><br><span class="line">        sink(vec,present,size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：时间复杂度为$O(nlog n)$</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>找到数组里数据的最大值max，并创建一个最大下标为max的空数组arr，遍历数组，将数据的出现次数填入arr对应的位置，遍历arr，依次取出即可完成排序，但是局限性很大，只适用于正整数且范围相差不大的数组排序使用，但速度相当可观</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找出数组中的最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i] &gt; max) &#123;</span><br><span class="line">            max = vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化计数数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countArr(max+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        countArr[vec[i]]++;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countArr.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (countArr[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            vec[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：时间复杂度为$O(n+m)$，m为数据量</p>
<h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><p>保持排序前后相同数据的顺序不变，对计数排序进行变形，countArr存放的是数据出现次数，那么我们可以将countArr里的每个元素顺序求和，取数据的时候则要把排名减1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stable_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找出数组中的最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i] &gt; max) &#123;</span><br><span class="line">            max = vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化计数数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countArr(max + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ve.size(); ++i)</span><br><span class="line">        countArr[arr[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顺序累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max + <span class="number">1</span>; ++i)</span><br><span class="line">        countArr[i] = countArr[i<span class="number">-1</span>] + countArr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序后的数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortedArr(vec.size(),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vec.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        sortedArr[countArr[vec[i]]<span class="number">-1</span>] = arr[i];</span><br><span class="line">        countArr[arr[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将排序后的数据拷贝到原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); ++i)</span><br><span class="line">        vec[i] = sortedArr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>可以看作是基数排序的升级版，把要排序的数据分到多个有序的桶里，每个桶里单独进行排序，然后依次取出即可完成排序，这里有几个问题需要考虑到：桶的表示、桶数量的确定、桶内排序的方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> size = vec.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i] &gt; max)</span><br><span class="line">            max = vec[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vec[i] &lt; min)</span><br><span class="line">            min = vec[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大值和最小值的差</span></span><br><span class="line">    <span class="keyword">int</span> diff = max - min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶列表</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bucketVec(size,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;);	<span class="comment">//桶的数量我设置成数组的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每个桶的存数区间</span></span><br><span class="line">    <span class="keyword">float</span> section = (<span class="keyword">float</span>) diff / (<span class="keyword">float</span>) (length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        <span class="comment">//当前数除以区间得出存放桶的位置 减1后得出桶的下标</span></span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>) (vec[i] / section) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>) num = <span class="number">0</span>;</span><br><span class="line">        bucketVec[num].push_back(vec[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶内排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketVec.size(); i++)</span><br><span class="line">        sort(bucketVec.begin(),bucketVec.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入原数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> b:bucketVec)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> value:b)</span><br><span class="line">            vec[index++]=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：最好情况下，即桶内没有进行排序，时间复杂度为$O(n)$，但是在桶与桶之间数据分布极不均匀的情况下，时间复杂度退化为$O(nlog n)$，解决办法是每次桶排序前判断一下数据量，如果桶内数据量过大，应该在桶内回调自身再进行一次桶排序</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>非比较型整数排序算法，将数据按位数切割成不同的数字，然后按每个位数分别比较，不管你的数位有多大，按位数排序，最多也就0-9十个桶，先按权重小的位置排序，然后按权重大的位置排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i] &gt; max)&#123;</span><br><span class="line">            max = vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前排序位置</span></span><br><span class="line">    <span class="keyword">int</span> location = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶列表</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bucketVec(<span class="number">10</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;);	<span class="comment">//桶的数量我设置成数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断是否排完</span></span><br><span class="line">        <span class="keyword">int</span> dd = (<span class="keyword">int</span>)Math.<span class="built_in">pow</span>(<span class="number">10</span>，(location - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(max &lt; dd)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据入桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算余数 放入相应的桶</span></span><br><span class="line">            <span class="keyword">int</span> number = ((vec[i] / dd) % <span class="number">10</span>);</span><br><span class="line">            bucketVec[number].push_back(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写回数组</span></span><br><span class="line">        <span class="keyword">int</span> nn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = bucketVec[i].size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>;ii &lt; s;ii ++)&#123;</span><br><span class="line">                vec[nn++] = bucketVec[i][ii];</span><br><span class="line">            &#125;</span><br><span class="line">            bucketVec[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        location++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/08/04/排序算法/" data-id="cjyzjijs0000wh8w17u6rb5rt" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-网易内推笔试总结" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/03/网易内推笔试总结/">网易内推笔试总结</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/03/网易内推笔试总结/" class="article-date">
  <time datetime="2019-08-03T08:53:39.000Z" itemprop="datePublished">2019-08-03</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <ul>
<li>写在前面  </li>
</ul>
<p>今天下午做了一下网易的内推笔试，这段时间一直在刷题，没注重基础知识的补充，所以在问答题上吃了大亏(问答题有两道，一道是关于智能指针的，另一道是inline函数的)，下面就来总结一下</p>
<hr>
<h3 id="smart-pointer"><a href="#smart-pointer" class="headerlink" title="smart pointer"></a>smart pointer</h3><p>在c++标准里，智能指针有4种，auto_ptr、shared_ptr、weak_ptr、unique_ptr，其中后面三个是c++11新加进来的，第一个是c++98的，在新标准中已经被抛弃</p>
<h5 id="auto-ptr-所有权模式"><a href="#auto-ptr-所有权模式" class="headerlink" title="auto_ptr(所有权模式)"></a>auto_ptr(所有权模式)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"test"</span>));</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p2;</span><br><span class="line">p2=p1;	<span class="comment">//此时并不报错</span></span><br><span class="line"><span class="comment">//p2剥夺了p1的所有权，当程序运行时如果访问到p1将会报错</span></span><br><span class="line"><span class="comment">//这是auto_ptr的缺点：存在潜在的内存崩溃问题</span></span><br></pre></td></tr></table></figure>
<h5 id="unique-ptr-替换auto-ptr，所有权模式，独占式拥有或严格拥有"><a href="#unique-ptr-替换auto-ptr，所有权模式，独占式拥有或严格拥有" class="headerlink" title="unique_ptr(替换auto_ptr，所有权模式，独占式拥有或严格拥有)"></a>unique_ptr(替换auto_ptr，所有权模式，独占式拥有或严格拥有)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保证同一时间内只有一个智能指针可以指向该对象，对于避免资源泄露特别有用</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"test"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;</span><br><span class="line">p4=p3;	<span class="comment">//报错，编译器认为p3=p4非法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此外，unique_ptr还有一个更聪明的地方，当程序试图将一个unique_ptr赋值给另一个时，如果源unique_ptr是临时右值，编译器允许会这么做，但是如果源unique_ptr将存在一段时间，编译器将禁止这一行为</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p5(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"test"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p6;</span><br><span class="line">p6=p5;	<span class="comment">//非法，因为这样会留下悬挂的p5，可能有潜在危害</span></span><br><span class="line"><span class="comment">//如果非要这么做的话，需要用安全的做法，同时也能给它赋新值</span></span><br><span class="line">p6=move(p5);	<span class="comment">//转移所有权</span></span><br><span class="line">p5=<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"new string"</span>);	<span class="comment">//赋新值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p7=<span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">"test"</span>));	<span class="comment">//允许</span></span><br></pre></td></tr></table></figure>
<h5 id="shared-ptr-共享式拥有，多个智能指针指向同一对象，当最后一个引用被销毁时资源释放"><a href="#shared-ptr-共享式拥有，多个智能指针指向同一对象，当最后一个引用被销毁时资源释放" class="headerlink" title="shared_ptr(共享式拥有，多个智能指针指向同一对象，当最后一个引用被销毁时资源释放)"></a>shared_ptr(共享式拥有，多个智能指针指向同一对象，当最后一个引用被销毁时资源释放)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过计数机制表明资源b被几个指针共享，可以通过use_count()查看资源所有者个数，可通过new进行构造，也可通过auto_ptr、unique_ptr、weak_ptr来构造，当调用release()时，当前指针释放所有权，计数减1，当计数为0时资源释放</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成员函数如下:</span></span><br><span class="line"><span class="comment">use_count	返回引用计数个数</span></span><br><span class="line"><span class="comment">unique	返回是否是独占所所有权(use_count为1)</span></span><br><span class="line"><span class="comment">swap	交换两个shared_ptr所拥有的对象</span></span><br><span class="line"><span class="comment">reset	放弃内部对象的所有权或拥有对象的变更，会引起原有对象引用计数的减少</span></span><br><span class="line"><span class="comment">get		返回内部对象指针，由于已经重载了()方法，因此和直接使用对象是一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="weak-ptr-不控制对象生命周期的智能指针"><a href="#weak-ptr-不控制对象生命周期的智能指针" class="headerlink" title="weak_ptr(不控制对象生命周期的智能指针)"></a>weak_ptr(不控制对象生命周期的智能指针)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指向一个shared_ptr管理的对象，进行该对象的内存管理是那个强引用的shared_ptr</span></span><br><span class="line"><span class="comment">weak_ptr只是提供了对管理对象的一个访问手段</span></span><br><span class="line"><span class="comment">设计目的是为配合shared_ptr而引入的一种智能指针来协助shared_ptr进行工作</span></span><br><span class="line"><span class="comment">它可以从一个shared_ptr或l另一个weak_ptr对象构造，其构造和析构不会引起计数的变化</span></span><br><span class="line"><span class="comment">用来解决shared_ptr的死锁问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb_;</span><br><span class="line">    ~A();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa_;</span><br><span class="line">    ~B();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pa和pb相互引用</span></span><br><span class="line">    pb-&gt;pa_=pa;</span><br><span class="line">    pa-&gt;pb_=pb;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pb.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当跳出fun函数时，智能指针pa和pb析构时两个资源引用计数会减1，但二者引用计数还是为1，导致跳出函数时资源没有b被释放(即析构函数没有被调用)，这时把其中一个shared_ptr改为weak_ptr即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">另外，weak_ptr不能直接访问对象的方法，需要先转化为shared_ptr才能进行操作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><ul>
<li><p>又称内联函数，用来建议编译器对一些特殊的函数进行内联扩展，节省每次调用函数的开支，但是需要在占用空间和程序效率上进行权衡，对过多的复杂的函数进行内联会带来很大的存储资源开支，对于递归函数的内联扩展则可能会引起部分编译器的无穷编译；</p>
</li>
<li><p>与宏相比较：宏调用不检查类型，而且进行的是文本替换，需要计算操作顺序，内联代码更方便调试</p>
</li>
<li>不足之处是对于基于C的编译系统，内联函数的使用在代码量增加的同时也可能大大增加编译时间</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/08/03/网易内推笔试总结/" data-id="cjyzjijr1000oh8w1i98j1ybo" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-iData习题课" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/04/13/iData习题课/">iData习题课</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/13/iData习题课/" class="article-date">
  <time datetime="2019-04-13T04:26:17.000Z" itemprop="datePublished">2019-04-13</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h3 id="Python命令注册"><a href="#Python命令注册" class="headerlink" title="Python命令注册"></a>Python命令注册</h3><blockquote>
<p>函数有三个参数: modelName(模块名或文件名)、methodName(无参函数名称)、message(命令提示信息)<br>注意: 注册命令后需要设置文件下次自动加载，重启iData后才有效果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#filename: myDemo.py</span></span><br><span class="line"><span class="keyword">from</span> AddCommand <span class="keyword">import</span> AddCommand</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pyMyPrint</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">AddCommand(<span class="string">'myDemo'</span>,<span class="string">'pyMyPrint'</span>,<span class="string">'Python打印'</span>)</span><br><span class="line"><span class="comment">#           模块名      函数名          函数说明</span></span><br></pre></td></tr></table></figure>
<h3 id="Python文件加密"><a href="#Python文件加密" class="headerlink" title="Python文件加密"></a>Python文件加密</h3><blockquote>
<p>iData提供了加密.py文件的设置。apploadpython之后，会看到”加密”选项，点击之后能将.py文件加密成不可解密的.pyc文件，只能被加载，不能被修改</p>
</blockquote>
<h3 id="高程点的展绘和提取"><a href="#高程点的展绘和提取" class="headerlink" title="高程点的展绘和提取"></a>高程点的展绘和提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PyiData <span class="keyword">as</span> pid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pyTestDrawDAT</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pid.isDocumentActived():</span><br><span class="line">        print(<span class="string">"文档未打开"</span>)</span><br><span class="line">        pid.iDataPrintf(<span class="string">"文档未打开"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    db=pid.getCurBase() <span class="comment">#获取数据库</span></span><br><span class="line">    geoCode=db.getGeoCodeIndex(<span class="string">'72010010'</span>)  <span class="comment">#获取高程点编码对象</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> geoCode.isValid():</span><br><span class="line">        print(<span class="string">"当前数据库不包含高程点编码"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    entityList=pid.iDataEntityList()</span><br><span class="line"></span><br><span class="line">    datFile=pid.getSourcePath()+<span class="string">"/demo/STUDY.DAT"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> open(datFile):</span><br><span class="line">        line=line.strip(<span class="string">'\n'</span>)   <span class="comment">#按行读取文件</span></span><br><span class="line">        temp=line.split(<span class="string">','</span>)    <span class="comment">#拆分字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#当读取没问题且高程不为0，将数据添加进列表</span></span><br><span class="line">        <span class="keyword">if</span> len(temp)==<span class="number">5</span> <span class="keyword">and</span> temp[<span class="number">4</span>]!=<span class="number">0</span>:</span><br><span class="line">            pos=pid.Point3D(float(temp[<span class="number">3</span>]),float(temp[<span class="number">2</span>]),float(temp[<span class="number">4</span>]))</span><br><span class="line">            point=pid.iDataPoint(geoCode,pos)</span><br><span class="line">            entityList.append(point)    <span class="comment">#创建点实体并加入列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> len(entityList)&gt;<span class="number">0</span>:</span><br><span class="line">        pid.iDataAppendEntity(entityList)   <span class="comment">#提交</span></span><br><span class="line">        pid.CommitEntity(entityList,pid.iData.kAppended)</span><br><span class="line">        <span class="comment">#pid.iDataExcuteCommand('zoom;e',500)    #延迟0.5秒执行缩放全图命令</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"没有添加任意高程点"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pyTestWriteDAT</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pid.isDocumentActived():</span><br><span class="line">        print(<span class="string">"文档未打开"</span>)</span><br><span class="line">        pid.iDataPrintf(<span class="string">"文档未打开"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#选择地貌点图层下的所有点</span></span><br><span class="line">    e,entityList=pid.iDataSSGetX(<span class="string">"TERPT"</span>)</span><br><span class="line">    <span class="keyword">if</span> len(entityList)==<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"地貌点图层没有实体"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#打开保存文件对话框</span></span><br><span class="line">    filename=pid.BasicUI_getSaveFileName(<span class="string">"选择要保存的文件"</span>,<span class="string">"C:\\"</span>,<span class="string">"DAT文件(*.dat)"</span>)</span><br><span class="line">    <span class="keyword">if</span> len(filename)==<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"放弃输出DAT文件"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    file=open(filename,<span class="string">"w"</span>) <span class="comment">#以写入方式打开文件</span></span><br><span class="line">    num=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> entity <span class="keyword">in</span> entityList:</span><br><span class="line">        point=pid.iDataEntity.convertToPoint(entity)    <span class="comment">#将抽象实体变为点实体</span></span><br><span class="line">        <span class="keyword">if</span> point.getCode()!=<span class="string">"72010010"</span>: <span class="comment">#过滤编码不是高程点的点</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        pos=point.getNode() <span class="comment">#取得点坐标</span></span><br><span class="line">        num+=<span class="number">1</span></span><br><span class="line">        dat_line=<span class="string">"%d,,%.3f,%.3f,%.3f\n"</span>%(num,pos.y(),pos.x(),pos.z())   <span class="comment">#设置写入格式</span></span><br><span class="line">        file.write(dat_line)    <span class="comment">#写入文件</span></span><br><span class="line">    file.close()    <span class="comment">#关闭文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pyTestDrawDAT()</span></span><br><span class="line">pyTestWriteDAT()</span><br></pre></td></tr></table></figure>
<h3 id="统计植被面积以及天然草地在植被中的面积占比"><a href="#统计植被面积以及天然草地在植被中的面积占比" class="headerlink" title="统计植被面积以及天然草地在植被中的面积占比"></a>统计植被面积以及天然草地在植被中的面积占比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> PyiData <span class="keyword">as</span> pid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pyTestStaticArea</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pid.isDocumentActived():</span><br><span class="line">        print(<span class="string">"文档未打开"</span>)</span><br><span class="line">        pid.iDataPrintf(<span class="string">"文档未打开"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 手动打开文档</span></span><br><span class="line">    <span class="comment"># mdbFileName=pid.getSourcePath()+"/demo/study.mdb"</span></span><br><span class="line">    <span class="comment"># isOk=pid.OpenDoc(mdbFileName)</span></span><br><span class="line">    <span class="comment"># if not isOk:</span></span><br><span class="line">    <span class="comment">#     print("无法打开MDB文件")</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#选择植被图层上的全部实体</span></span><br><span class="line">    e,entityList=pid.iDataSSGetX(<span class="string">"VEGNT"</span>)</span><br><span class="line">    <span class="keyword">if</span> len(entityList)==<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"植被面图层没有实体"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    area_total=<span class="number">0.0</span></span><br><span class="line">    area=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> entity <span class="keyword">in</span> entityList:</span><br><span class="line">        area_total+=entity.getArea()    <span class="comment">#统计植被面积</span></span><br><span class="line">        <span class="keyword">if</span> entity.getCode()==<span class="string">"81060230"</span>:    <span class="comment">#统计天然植被面积</span></span><br><span class="line">            area+=entity.getArea()</span><br><span class="line">            entity.setHighLight(<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> math.fabs(area_total)&gt;<span class="number">0</span>:</span><br><span class="line">        per=<span class="number">100</span>*area/area_total</span><br><span class="line">        print(<span class="string">"当前图面植被面积%3.2f m^2, 其中天然草地面积%3.2f m^2, 占%.1f%%"</span>%(area_total,area,per))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"无法统计面积"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="输出Excel报表"><a href="#输出Excel报表" class="headerlink" title="输出Excel报表"></a>输出Excel报表</h3><blockquote>
<p>实例代码为每一个房屋面输出一个Excel信息表，表中有房屋的各种属性以及渲染图片</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PyiData <span class="keyword">as</span> pid</span><br><span class="line"><span class="keyword">import</span> xlsxwrite</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pyTestWriteXLSX</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pid.isDocumentActived():</span><br><span class="line">        print(<span class="string">"文档未打开"</span>)</span><br><span class="line">        pid.iDataPrintf(<span class="string">"文档未打开"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择居民地面图层没有的实体</span></span><br><span class="line">    e, entityList = pid.iDataSSGetX(<span class="string">"RESNT"</span>)</span><br><span class="line">    <span class="keyword">if</span> len(entityList) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"居民地面图层没有实体"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开保存文件对话框</span></span><br><span class="line">    fileDir = pid.BasicUI_getExistingDirectory(<span class="string">"选择要保存EXcel的文件夹"</span>, <span class="string">"C:\\"</span>)</span><br><span class="line">    <span class="keyword">if</span> len(fileDir) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"放弃输出文件"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fileDir.endswith(<span class="string">'/'</span>):</span><br><span class="line">        fileDir += <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">    pid.iDataCreateProgress(<span class="string">"输出房屋信息"</span>)  <span class="comment"># 创建进度条</span></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> entity <span class="keyword">in</span> entityList:</span><br><span class="line">        current += <span class="number">1</span></span><br><span class="line">        pid.iDataSetProgressValue(current, entityList.size())  <span class="comment"># 修改进度条数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current &gt; <span class="number">10</span>:  <span class="comment"># 测试过程减少输出数量</span></span><br><span class="line">            print(<span class="string">"可输出Excel数量超过10，测试超过10即停止"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        oid = str(entity.getOID())  <span class="comment"># 用OID做名称</span></span><br><span class="line">        xlsxName = fileDir + oid + <span class="string">".xlsx"</span>  <span class="comment"># Excel文件名</span></span><br><span class="line"></span><br><span class="line">        workBook = xlsxwriter.Workbook(xlsxName)  <span class="comment"># 创建工作簿</span></span><br><span class="line">        workSheet = workBook.add_worksheet()  <span class="comment"># 添加一个Sheet</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置列宽</span></span><br><span class="line">        workSheet.set_column(<span class="string">'A:A'</span>, <span class="number">20</span>)</span><br><span class="line">        workSheet.set_column(<span class="string">'B:B'</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置以及合并表头</span></span><br><span class="line">        merge_format = workBook.add_format(&#123;</span><br><span class="line">            <span class="string">'font_size'</span>: <span class="number">16</span>,</span><br><span class="line">            <span class="string">'bold'</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="comment"># 'bolder': 1,</span></span><br><span class="line">            <span class="string">'align'</span>: <span class="string">'center'</span>,</span><br><span class="line">            <span class="string">'valign'</span>: <span class="string">'vcenter'</span>,</span><br><span class="line">            <span class="string">'fg_color'</span>: <span class="string">'yellow'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        workSheet.merge_range(<span class="string">'A1:B1'</span>, <span class="string">'XXX房屋信息表'</span>, merge_format)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置单元格格式</span></span><br><span class="line">        bold = workBook.add_format(&#123;<span class="string">'bold'</span>: <span class="keyword">True</span>, <span class="string">'align'</span>: <span class="string">'center'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写入数据</span></span><br><span class="line">        workSheet.write(<span class="string">'A2'</span>, <span class="string">'房屋层数: '</span>, bold)</span><br><span class="line">        workSheet.write_number(<span class="string">'B2'</span>, entity.getXData(<span class="string">'FWSC'</span>).toInt())</span><br><span class="line">        workSheet.write(<span class="string">'A3'</span>, <span class="string">'地下房屋层数: '</span>, bold)</span><br><span class="line">        workSheet.write_number(<span class="string">'B3'</span>, entity.getXData(<span class="string">'DXFWSC'</span>).toInt())</span><br><span class="line">        workSheet.write(<span class="string">'A4'</span>, <span class="string">'房屋类型: '</span>, bold)</span><br><span class="line">        workSheet.write(<span class="string">'B4'</span>, entity.getXData(<span class="string">'FWLX'</span>).toString())</span><br><span class="line">        workSheet.write(<span class="string">'A5'</span>, <span class="string">'名称: '</span>, bold)</span><br><span class="line">        workSheet.write(<span class="string">'B5'</span>, entity.getXData(<span class="string">'MC'</span>).toString())</span><br><span class="line">        workSheet.write(<span class="string">'A6'</span>, <span class="string">'类别名称: '</span>, bold)</span><br><span class="line">        workSheet.write(<span class="string">'B6'</span>, entity.getName())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 插入图片</span></span><br><span class="line">        workSheet.merge_range(<span class="string">'A8:B22'</span>, <span class="string">'房屋图片'</span>)</span><br><span class="line">        picName = fileDir + oid + <span class="string">'.png'</span></span><br><span class="line">        pid.saveEntitysToImage(picName, <span class="number">500</span>, <span class="number">300</span>, entity)</span><br><span class="line">        workSheet.insert_image(<span class="string">'A8'</span>, picName, &#123;<span class="string">'x_scale'</span>: <span class="number">0.8</span>, <span class="string">'y_scale'</span>: <span class="number">0.8</span>&#125;)  <span class="comment"># 缩放为80%</span></span><br><span class="line"></span><br><span class="line">        workBook.close()  <span class="comment"># 关闭工作簿</span></span><br><span class="line"></span><br><span class="line">    pid.iDataCloseProgress()  <span class="comment"># 关闭进度条</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/04/13/iData习题课/" data-id="cjyzjijqf000gh8w1rvq1w6d1" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-数据库图层编码字段" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/04/08/数据库图层编码字段/">数据库图层编码字段</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/08/数据库图层编码字段/" class="article-date">
  <time datetime="2019-04-08T15:36:24.000Z" itemprop="datePublished">2019-04-08</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h4 id="数据库DbBase"><a href="#数据库DbBase" class="headerlink" title="数据库DbBase"></a>数据库DbBase</h4><p>表示一个打开数据库对象，可获取数据中的信息</p>
<ul>
<li>dbName: 获取数据库路径</li>
<li>Type: 数据库类型</li>
<li>geoCodeList: 获取实体编码列表</li>
<li>layerList: 获取全部图层列表</li>
<li>getLayer: 获取指定图层<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dbBase=pid.getCurBase() <span class="comment">#获取数据库对象</span></span><br><span class="line">print(<span class="string">'数据库路径: '</span>,dbBase.dbName())</span><br><span class="line"><span class="comment">#kDBDefault\kSqlite\kGisPdb\kShape\kSDE\KCAD\KDGN\kGisEdb</span></span><br><span class="line">print(<span class="string">'是不是MDB数据库?'</span>,dbBase.Type()==pid.iData.kGisPdb)</span><br><span class="line"></span><br><span class="line">layers=dbBase.layerList() <span class="comment">#获取所有图层</span></span><br><span class="line">print(<span class="string">'数据库中有'</span>,len(layers),<span class="string">'个图层，分别是: '</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> layers:  <span class="comment">#打印图层名和别名</span></span><br><span class="line">  print(i.getName(),i.getAliasName())</span><br><span class="line">  </span><br><span class="line">geoCodes=dbBase.geoCodeList() <span class="comment">#获取所有编码</span></span><br><span class="line">print(<span class="string">'数据库中有'</span>,len(geoCodes),<span class="string">'个编码'</span>)</span><br><span class="line"></span><br><span class="line">e,layer=dbBase.getLayer(<span class="string">'ROANT'</span>)  <span class="comment">#获取指定图层</span></span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk <span class="keyword">and</span> layer.isValid():</span><br><span class="line">  print(<span class="string">'本数据库中存在ROANT图层'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'LCA图层不存在'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="图层iDataLayer"><a href="#图层iDataLayer" class="headerlink" title="图层iDataLayer"></a>图层iDataLayer</h4><ul>
<li>getName: 图层名</li>
<li>getAliasName: 图层别名</li>
<li>getLayerType: 图层类型</li>
<li>getGeoCodeList: 图层上的编码列表</li>
<li>items: 图层包含的所有实体</li>
<li>xDataFields: 所有扩展属性字段</li>
<li>field: 获取指定属性字段</li>
<li>itemsBoundingRect: 图层外包矩形<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dbBase=pid.getCurBase() <span class="comment">#获取数据库对象</span></span><br><span class="line">e,layer=dbBase.getLayer(<span class="string">'TERLK'</span>)  <span class="comment">#获取指定图层</span></span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk <span class="keyword">and</span> layer.isValid():</span><br><span class="line">  print(<span class="string">'图层名'</span>,layer.getName(),<span class="string">'别名'</span>,layer.getAliasName())</span><br><span class="line">  entitys=layer.items() <span class="comment">#获取图层上的所有实体，同iDataSSGetX</span></span><br><span class="line">  print(<span class="string">'图层上有'</span>,len(entitys),<span class="string">'个实体'</span>)</span><br><span class="line">  <span class="keyword">del</span> entitys</span><br><span class="line">  geoCodes=layer.getGeoCodeList() <span class="comment">#获取本图层额编码列表</span></span><br><span class="line">  print(<span class="string">'TERLK图层中有'</span>,len(geoCodes),<span class="string">'个编码，分别是: '</span>)</span><br><span class="line">  <span class="keyword">for</span> c <span class="keyword">in</span> geoCodes:</span><br><span class="line">    print(c.getCode(),c.getUserName())  <span class="comment">#编码以及用户定义的名称</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'TERLK图层不存在'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dbBase=pid.getCurBase() <span class="comment">#获取数据库对象</span></span><br><span class="line">geoCode=dbBase.getGeoCodeIndex(<span class="string">'76010221'</span>)</span><br><span class="line"><span class="keyword">if</span> geoCode.isValid():</span><br><span class="line">  print(geoCode.getCode(),<span class="string">':'</span>,geoCode.getUserName())</span><br><span class="line">  color=geoCode.getColorIndex()</span><br><span class="line">  print(<span class="string">'颜色索引'</span>,color)</span><br><span class="line">  color=pid.iData_GetColor(color) <span class="comment">#通过索引拿到颜色RGB</span></span><br><span class="line">  print(<span class="string">'颜色'</span>,color)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'当前数据库中不包含(76010221)的编码'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里有个自定义的函数v2i需要注意一下</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">v2i</span><span class="params">(d)</span>:</span></span><br><span class="line">  v=pid.Variant()</span><br><span class="line">  v.setValue(d)</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">db=pid.getCurBase() <span class="comment">#获取数据库</span></span><br><span class="line">print(<span class="string">'Current DataBase is: '</span>,db.dbName())</span><br><span class="line"><span class="comment">#获取建成房屋(31030130)的编码对象</span></span><br><span class="line">geoCode=db.getGeoCodeIndex(<span class="string">'31030130'</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> geoCode.isValid():</span><br><span class="line">  print(<span class="string">'当前数据库不包含建成房屋(31030130)的编码'</span>)</span><br><span class="line">e,point=pid.iDataGetPoint(<span class="string">'在图面上点选一个点'</span>)</span><br><span class="line"><span class="keyword">if</span> e!=pid.iData.eOk:</span><br><span class="line">  print(<span class="string">'用户放弃选择'</span>)</span><br><span class="line"></span><br><span class="line">x0=point.x()</span><br><span class="line">y0=point.y()</span><br><span class="line"></span><br><span class="line">arrNodes=pid.Point3DListList()</span><br><span class="line"><span class="comment">#绘制面，需要闭合的点，最好是顺时针</span></span><br><span class="line">posList=pid.Point3DList()</span><br><span class="line">posList.append(pid.Point3D(x0,y0,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(x0,y0+<span class="number">30</span>,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(x0+<span class="number">30</span>,y0+<span class="number">30</span>,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(x0+<span class="number">30</span>,y0,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(x0,y0,<span class="number">0</span>))</span><br><span class="line">arrNodes.append(posList)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建实体</span></span><br><span class="line">entity=pid.iDataPolygon(geoCode,arrNodes,pid.DoubleListList())</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置各种属性(必须是实体编码中存在的字段)</span></span><br><span class="line"><span class="comment">#print(pid.version&lt;'1.3.26548')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">entity.setXData('FWCS',5)</span></span><br><span class="line"><span class="string">entity.setXData('DXFWCS',1)</span></span><br><span class="line"><span class="string">entity.setXData('FWLX','一般房屋')</span></span><br><span class="line"><span class="string">entity.setXData('GD',18.6)</span></span><br><span class="line"><span class="string">entity.setXData('JGLX','砼')</span></span><br><span class="line"><span class="string">entity.setXData('YT','住宅')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#版本1.3.26548以下只能用下面的写法，高版本直接用上面的写法</span></span><br><span class="line"><span class="comment">#低版本需要做个数据的类型转换</span></span><br><span class="line">entity.setXData(<span class="string">'FWCS'</span>,v2i(<span class="number">5</span>))</span><br><span class="line">entity.setXData(<span class="string">'DXFWCS'</span>,v2i(<span class="number">1</span>))</span><br><span class="line">entity.setXData(<span class="string">'FWLX'</span>,v2i(<span class="string">'一般房屋'</span>))</span><br><span class="line">entity.setXData(<span class="string">'GD'</span>,v2i(<span class="number">18.6</span>))</span><br><span class="line">entity.setXData(<span class="string">'JGLX'</span>,v2i(<span class="string">'砼'</span>))</span><br><span class="line">entity.setXData(<span class="string">'YT'</span>,v2i(<span class="string">'住宅'</span>))</span><br><span class="line">entity.setXData(<span class="string">'MC'</span>,v2i(<span class="string">'测试房屋'</span>))</span><br><span class="line"></span><br><span class="line">pid.iDataAppendEntity(entity) <span class="comment">#将实体提交到图面</span></span><br><span class="line">pid.CommitEntity(entity,pid.iData.kAppended)  <span class="comment">#提交到数据库</span></span><br><span class="line">pid.iDataRegen(<span class="keyword">None</span>,<span class="keyword">True</span>) <span class="comment">#刷新图面</span></span><br></pre></td></tr></table></figure>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li><p>文档<br>iData文档相关接口常用的方法如下<br>OpenDoc: 打开文件<br>CloseDoc: 关闭文件<br>getCurBase: 获取当前文件所打开的数据库对象<br>getCurDocPath: 当前文档的路径<br>getSourcePath: 获取当前运行程序的运行环境路径<br>isDocumentActived: 判断当前视图中是否有文档打开</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">isOk=pid.isDocumentActived()  <span class="comment">#获取文档打开状态</span></span><br><span class="line">docPath=<span class="string">'D:\\A\\Program  Pratice\\iData\\idata-standard-1.3\\demo\\study.mdb'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isOk:</span><br><span class="line">  isOk=pid.OpenDoc(docPath)</span><br><span class="line">  print(<span class="string">'打开文档'</span>,docPath)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  db=pid.getCurBase() <span class="comment">#获取数据库对象</span></span><br><span class="line">  print(<span class="string">'当前打开数据库: '</span>,db.dbName())  <span class="comment">#获取数据库的名称</span></span><br><span class="line">  docPath=pid.getCurDocPath() <span class="comment">#获取当前打开的文档路径</span></span><br><span class="line">  print(<span class="string">'已经打开文档'</span>,docPath)</span><br><span class="line">  isOk=pid.CloseDoc(docPath) <span class="comment">#关闭文档</span></span><br><span class="line">  print(<span class="string">'关闭文档'</span>,docPath)</span><br><span class="line"></span><br><span class="line">print(pid.getSourcePath())  <span class="comment">#获取iData程序运行路径</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对话框<br>iData接口，包含了大部分常用操作<br>getOpenFileName: 打开文件对话框<br>getOpenFileNames: 打开文件对话框(多选)<br>getExistingDirectory: 打开目录对话框<br>getSaveFileName: 保存文件对话框<br>GetCustomColorDlg: 选择颜色对话框</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开文件对话框</span></span><br><span class="line">fileName=pid.getOpenFileName(<span class="string">'选择单个文件'</span>,<span class="string">'D:\\'</span>,<span class="string">'数据库(*.mdb)'</span>)</span><br><span class="line">print(<span class="string">'选择了文件'</span>,fileName)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存文件对话框</span></span><br><span class="line">fileName=pid.getSaveFileName(<span class="string">'保存文件'</span>,<span class="string">'D:\\'</span>)</span><br><span class="line">print(<span class="string">'保存了文件'</span>，fileName)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开多选文件对话框</span></span><br><span class="line">fileNameList=pid.getOpenFileName(<span class="string">'选择多个文件'</span>,<span class="string">'D:\\'</span>,<span class="string">'数据库(*.mdb)'</span>)</span><br><span class="line">print(<span class="string">'选择了文件'</span>，len(fileNameList),<span class="string">'个: '</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> fileNameList:</span><br><span class="line">  print(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择目录对话框</span></span><br><span class="line">dirName=pid.getExistingDirectory(<span class="string">'Python选择目录'</span>,<span class="string">'D:\\'</span>)</span><br><span class="line">print(<span class="string">'选择了文件夹: '</span>,dirName)</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择颜色对话框</span></span><br><span class="line">ci=pid.getCustomColorDlg(<span class="number">0</span>)</span><br><span class="line">print(ci) <span class="comment">#用户选择了数据源中的颜色</span></span><br><span class="line">c=pid.iData_GetColor(ci)  <span class="comment">#通过索引拿到颜色RGB</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
</li>
<li><p>交互<br>iDataPrintf: 打印<br>iDataInitGet: 初始化关键字<br>iDataGetString: 获取字符串<br>iDataGetInt: 获取整数数值<br>iDataGetReal: 获取浮点数值<br>iDataGetPoint: 选择一个点<br>iDataGetCorner: 拉框选择点<br>iDataGetOrient: 获取线段和X轴的夹角</p>
</li>
<li><p>选择<br>iData接口包含丰富强大的选择功能，可根据不同的需求组合选择出所需要的实体，常用的选择接口如下:<br>iDataEntSel: 单击鼠标选择实体<br>iDataSSGetX: 选择给定的图层上的实体<br>iDataSSGet: 根据给定的点、矩形、多边形等，在给定图层上选择实体<br>iDataGetSelectedEntitys: 获取视图中被选中的实体<br>ClearSelection: 取消对实体的选择状态<br>iDataGetItemsBoundingRect: 获取视图中所有实体的最大外包矩形  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用鼠标在屏幕上点击选择单个实体</span></span><br><span class="line">e,entity,point=pid.iDataEntSel(<span class="string">'鼠标屏幕点选实体: '</span>)</span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk:</span><br><span class="line">  print(<span class="string">'选择了一个实体'</span>)</span><br><span class="line">  print(entity)</span><br><span class="line">  print(<span class="string">'点击位置: '</span>,point)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用鼠标以任意方式选择实体</span></span><br><span class="line">e,entityList=pid.iDataSSGet(<span class="string">'选择实体: '</span>)</span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk:</span><br><span class="line">  print(<span class="string">'选了'</span>,len(entityList),<span class="string">'个实体'</span>)</span><br><span class="line"></span><br><span class="line">e,entityList=pid.iDataSSGetX()  <span class="comment">#选择图面所有实体</span></span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk:</span><br><span class="line">  pid.iDataDeleteEntity(entityList) <span class="comment">#从图面删除</span></span><br><span class="line">  pid.CommitEntity(entityList,pid.iData.kErased)  <span class="comment">#从数据库中删除</span></span><br><span class="line">  pid.iDataRegen(<span class="keyword">None</span>,<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">del</span> entityList  <span class="comment">#清空列表</span></span><br><span class="line"></span><br><span class="line">e,entityList=pid.iDataSSGetX([<span class="string">'IDATA'</span>,<span class="string">'ROANT'</span>])  <span class="comment">#选择图面所有实体</span></span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk:</span><br><span class="line">  print(<span class="string">'指定图层上有'</span>,len(entityList),<span class="string">'个实体'</span>)</span><br><span class="line"><span class="keyword">for</span> entity <span class="keyword">in</span> entityList:</span><br><span class="line">    entity.setHighLight(<span class="keyword">True</span>)</span><br><span class="line">pid.iDataRegen(pid.Rect(),<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">del</span> entityList</span><br><span class="line"></span><br><span class="line">pid.iDataExcuteCommand(<span class="string">'undo;1'</span>)  <span class="comment">#执行undo命令，带的参数1表示回退一步，效果同命令行输入一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在指定区域内选择IDATA图层上的实体，框选</span></span><br><span class="line">rect=pid.Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">250</span>,<span class="number">250</span>)</span><br><span class="line">e,entityList=pid.iDataSSGetRect(rect,pid.iData.ContainsItemShape,[<span class="string">'IDATA'</span>])</span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk:</span><br><span class="line">  print(<span class="string">'在指定区域中找到'</span>,len(entityList),<span class="string">'个实体'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在指定区域内选择IDATA图层上的实体，交选</span></span><br><span class="line">rect=pid.Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">250</span>,<span class="number">250</span>)</span><br><span class="line">e,entityList=pid.iDataSSGetRect(rect,pid.iData.IntersectItemsShape,[<span class="string">'IDATA'</span>])</span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk:</span><br><span class="line">  print(<span class="string">'在指定区域中找到'</span>,len(entityList),<span class="string">'个实体'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里除了iDataSSGetRect还有iDataSSGetPolgon,通过多边形来选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取图面中被选中的实体</span></span><br><span class="line">e,entityList=pid.iDataGetSelectedEntitys()</span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk:</span><br><span class="line">  print(<span class="string">'当前图面中选中了'</span>,len(entityList),<span class="string">'个实体'</span>)</span><br><span class="line">pid.ClearSelection()  <span class="comment">#清除图面的选择</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/04/08/数据库图层编码字段/" data-id="cjyzjijrq000uh8w1g717ldfz" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-cpp-STL" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/03/10/cpp-STL/">cpp-STL</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/03/10/cpp-STL/" class="article-date">
  <time datetime="2019-03-10T15:08:10.000Z" itemprop="datePublished">2019-03-10</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h3 id="STL-forward-list"><a href="#STL-forward-list" class="headerlink" title="STL-forward_list"></a>STL-forward_list</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    arr.assign(&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;);  <span class="comment">//分配数据</span></span><br><span class="line">    arr.assign(<span class="number">5</span>,<span class="number">10</span>);       <span class="comment">//分配5个重复的数据(会覆盖之前的)</span></span><br><span class="line">    </span><br><span class="line">    arr.push_front(<span class="number">1</span>);  <span class="comment">//在arr前面插入数据</span></span><br><span class="line">    arr.pop_front();    <span class="comment">//删除arr前面一个数据，返回值为void</span></span><br><span class="line"></span><br><span class="line">    arr.emplace_front(<span class="number">1</span>);   <span class="comment">//在arr前面插入一个数据</span></span><br><span class="line">    </span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt;::iterator a=arr.begin();  <span class="comment">//一个指向arr头位置的迭代器指针</span></span><br><span class="line">    arr.emplace_after(a,<span class="number">10</span>);  <span class="comment">//emplace_after方法需要两个参数，第一个是迭代器指针，第二个是数据，返回一个迭代器指针</span></span><br><span class="line">    </span><br><span class="line">    arr.insert_after(a,<span class="number">10</span>); <span class="comment">//insert_after方法需要两个参数，第一个是迭代器指针，第二个是数据，返回一个迭代器指针</span></span><br><span class="line">    </span><br><span class="line">    arr.erase_after(a);     <span class="comment">//删除迭代器指针后的一个数据</span></span><br><span class="line">    </span><br><span class="line">    arr.remove(<span class="number">1</span>);  <span class="comment">//删除arr中的所有值为1的数据</span></span><br><span class="line"></span><br><span class="line">    arr.remove_if([](<span class="keyword">int</span> m)&#123;<span class="keyword">return</span> m%<span class="number">2</span>;&#125;)   <span class="comment">//删除符合函数条件的数据，remove_if参数为一个函数</span></span><br><span class="line"></span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">    arr2.assgin(&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);</span><br><span class="line">    arr.splice_after(arr.begin(),arr2,arr2.begin(),arr2.end()); <span class="comment">//用于拼接两个链表，有四个参数，分别是被拼接链表的迭代器指针，拼接的链表，拼接链表的起始位置，拼接链表的终止位置；第三个参数为begin时不包括拼接内容的第一个位置，为before_begin时包括第一个位置</span></span><br><span class="line"></span><br><span class="line">    arr.front();    <span class="comment">//返回arr第一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*----------------------------------------------</span></span><br><span class="line"><span class="comment">      这里提一下begin、end和cbegin、cend的区别:</span></span><br><span class="line"><span class="comment">      四个方法返回的都是一个迭代器指针，但是c开头的方法返回的是const内容，不能通过它们修改容器里的内容，但是可以移动该指针</span></span><br><span class="line"><span class="comment">    ----------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    arr.max_size(); <span class="comment">//返回arr能存入的元素最大值</span></span><br><span class="line"></span><br><span class="line">    arr.resize(n);   <span class="comment">//修改arr的容量，当前容量大于n，删除大于部分；小于n，用0补全</span></span><br><span class="line"></span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt;::iterator b;  <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(b=arr.begin();b!=arr.end();++b) <span class="comment">//通过迭代器实现遍历</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*b&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="STL-array"><a href="#STL-array" class="headerlink" title="STL-array"></a>STL-array</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt;arr=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;	<span class="comment">//指定数组的类型和容量，可以之后再指定元素</span></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>,5&gt; arr2;</span><br><span class="line">    </span><br><span class="line">    arr2.fill(<span class="number">0</span>);	<span class="comment">//fill方法将数组内元素全部置为指定值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr2[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    arr2=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    arr.swap(arr2);	<span class="comment">//交换两个数组，两个数组容量要相等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;arr2[i]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)	<span class="comment">//at方法可访问指定的位置元素</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"arr.at("</span>&lt;&lt;i&lt;&lt;<span class="string">"): "</span>&lt;&lt;arr.at(i)&lt;&lt;<span class="string">"\tarr["</span>&lt;&lt;i&lt;&lt;<span class="string">"]: "</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"arr.size(): "</span>&lt;&lt;arr.size()&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//返回数组元素总和</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"arr.max_size(): "</span>&lt;&lt;arr.max_size()&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//返回数组最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"get&lt;0&gt;(arr): "</span>&lt;&lt;get&lt;<span class="number">0</span>&gt;(arr)&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//get方法重载自tuple，arry内没有，指定要访问的位置和相应的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"arr.front(): "</span>&lt;&lt;arr.front()&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//返回数组第一位元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"arr.back(): "</span>&lt;&lt;arr.back()&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//返回数组末尾元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arr.empty()&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//判断数组是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="STL-vector"><a href="#STL-vector" class="headerlink" title="STL-vector"></a>STL-vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        vec.push_back(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=vec.begin();i!=vec.end();++i)	<span class="comment">//迭代器指针</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=vec.cbegin();i!=vec.cend();++i)	<span class="comment">//const迭代器指针</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=vec.rbegin();i!=vec.rend();++i)	<span class="comment">//reverse，一个逆序指针</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=vec.crbegin();i!=vec.crend();++i)	<span class="comment">//const一个逆序指针</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.size()&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//vec的当前元素总数量</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.max_size()&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//vec的能容纳最大元素数量</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.capacity()&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//vec当前分配的容量，若超过容量，对成倍增加容量</span></span><br><span class="line"></span><br><span class="line">    vec.resize(<span class="number">2</span>);	<span class="comment">//将vec元素数量置为指定值，多于指定容量部分不会删除，但是通过迭代器无法访问，能通过[]访问，若不多于则用0补全</span></span><br><span class="line">    vec.shrink_to_fit();	<span class="comment">//将resize后多于容量的部分删除</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.empty()&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//判空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2;</span><br><span class="line">    vec2.reserve(<span class="number">5</span>);	<span class="comment">//要求vec2至少能填满5个元素，如果默认容量少于指定数值，会再分配默认容量，否则不会再分配(经过reserve后，插入元素的速度会变快)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment">        *	vector的[]、at、front、back、assgin、push_back、</span></span><br><span class="line"><span class="comment">        *	pop_back、insert、erase、swap、emplace、emplace_back等方法用法跟array一样</span></span><br><span class="line"><span class="comment">    ***********************************************************/</span></span><br><span class="line">    vec.clear();		<span class="comment">//清空vec</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/03/10/cpp-STL/" data-id="cjyzjijpl0004h8w1uf07rahf" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-iData实体" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/03/08/iData实体/">iData实体</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/03/08/iData实体/" class="article-date">
  <time datetime="2019-03-08T14:50:01.000Z" itemprop="datePublished">2019-03-08</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><ul>
<li>iData图面上的点、线、面、文字注记、影像等元素<br>分别为iDataPoint、iDataPolyline、iDataPolygon、iDataText、iDataImage，它们都继承自iDataEntity类<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">e,entity,point=pid.iDataEntSel(<span class="string">'select an entity you want to check: '</span>)</span><br><span class="line"><span class="comment">#iDataEntSel方法用来选择一个实体，返回三参数，后两个分别是实体以及选定点的坐标</span></span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk:</span><br><span class="line">  t=entity.type()   <span class="comment">#实体类型</span></span><br><span class="line">  print(e)</span><br><span class="line">  print(entity)</span><br><span class="line">  print(point)</span><br><span class="line">  <span class="keyword">if</span> t==pid.iData.IDATAPOINT:</span><br><span class="line">    print(<span class="string">'point'</span>)</span><br><span class="line">  <span class="keyword">elif</span> t==pid.iData.IDATAPOLYLINE:</span><br><span class="line">    print(<span class="string">'line'</span>)</span><br><span class="line">  <span class="keyword">elif</span> t==pid.iData.IDATAPOLYGON:</span><br><span class="line">    print(<span class="string">'gon'</span>)</span><br><span class="line">  <span class="keyword">elif</span> t==pid.iData.IDATATEXT:</span><br><span class="line">    print(<span class="string">'text'</span>)</span><br><span class="line">  <span class="keyword">elif</span> t==pid.iData.IDATAIMAGE:</span><br><span class="line">    print(<span class="string">'image'</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"I don't know what is this..."</span>)</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">  nodes,bulges=entity.getNodes()  <span class="comment">#取得实体节点</span></span><br><span class="line">  <span class="comment">#两个参数的类型都是ListList</span></span><br><span class="line">  print(<span class="string">'实体由&#123;&#125;部分组成'</span>.format(nodes.size()))</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nodes)):</span><br><span class="line">    print(<span class="string">'&#123;&#125;部分包含&#123;&#125;个节点'</span>.format(i+<span class="number">1</span>,len(nodes[i])))</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> nodes[i]:</span><br><span class="line">      print(p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'esc'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="实体几何"><a href="#实体几何" class="headerlink" title="实体几何"></a>实体几何</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建点实体</span></span><br><span class="line">geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOINT) <span class="comment">#获取默认点编码</span></span><br><span class="line">pos=pid.Point3D(<span class="number">250</span>,<span class="number">250</span>,<span class="number">3.14</span>) <span class="comment">#给定点坐标</span></span><br><span class="line">entity=pid.iDataPoint(geoCode,pos)  <span class="comment">#创建一个点实体</span></span><br><span class="line"></span><br><span class="line">pid.iDataAppendEntity(entity) <span class="comment">#将实体提交到图面</span></span><br><span class="line">pid.CommitEntity(entity,pid.iData.kAppended)  <span class="comment">#提交到数据库</span></span><br><span class="line"></span><br><span class="line">pid.iDataRegen(<span class="keyword">None</span>,<span class="keyword">True</span>) <span class="comment">#刷新图面</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment">#创建线实体</span></span><br><span class="line">arrNodes=pid.Point3DListList()  <span class="comment">#节点列表</span></span><br><span class="line">arrBulges=pid.DoubleListList()  <span class="comment">#凸度列表，如不需要留空即可</span></span><br><span class="line"></span><br><span class="line">posList=pid.Point3DList() <span class="comment">#坐标列表</span></span><br><span class="line">posList.append(pid.Point3D(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(<span class="number">1000</span>,<span class="number">250</span>,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(<span class="number">500</span>,<span class="number">1000</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">arrNodes.append(posList)</span><br><span class="line"></span><br><span class="line">geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOLYLINE)</span><br><span class="line">entity=pid.iDataPolyline(geoCode,arrNodes,arrBulges)</span><br><span class="line"></span><br><span class="line">pid.iDataAppendEntity(entity) <span class="comment">#实体提交到图面</span></span><br><span class="line">pid.CommitEntity(entity,pid.iData.kAppended)  <span class="comment">#实体提交到数据库</span></span><br><span class="line">pid.iDataRegen(<span class="keyword">None</span>,<span class="keyword">True</span>) <span class="comment">#刷新图面</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="comment">#创建面实体</span></span><br><span class="line">arrNodes=pid.Point3DListList()  <span class="comment">#节点列表</span></span><br><span class="line">arrBulges=pid.DoubleListList()  <span class="comment">#凸度列表，如不需要留空即可</span></span><br><span class="line"></span><br><span class="line">posList=pid.Point3DList() <span class="comment">#坐标列表</span></span><br><span class="line"><span class="comment">#构建多边形需要闭合</span></span><br><span class="line">posList.append(pid.Point3D(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(<span class="number">250</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(<span class="number">0</span>,<span class="number">250</span>,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">arrNodes.append(posList)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取默认面编码，并创建实体</span></span><br><span class="line">geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOLYGON)</span><br><span class="line">entity=pid.iDataPolygon(geoCode,arrNodes,arrBulges)</span><br><span class="line"></span><br><span class="line">pid.iDataAppendEntity(entity) <span class="comment">#实体提交到图面</span></span><br><span class="line">pid.CommitEntity(entity,pid.iData.kAppended)  <span class="comment">#实体提交到数据库</span></span><br><span class="line">pid.iDataRegen(<span class="keyword">None</span>,<span class="keyword">True</span>) <span class="comment">#刷新图面</span></span><br></pre></td></tr></table></figure>
<h4 id="实体凸度"><a href="#实体凸度" class="headerlink" title="实体凸度"></a>实体凸度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个圆</span></span><br><span class="line">arrNodes=pid.Point3DListList()  <span class="comment">#节点列表</span></span><br><span class="line">arrBulges=pid.DoubleListList()  <span class="comment">#凸度列表，如不需要留空即可</span></span><br><span class="line"></span><br><span class="line">posList=pid.Point3DList() <span class="comment">#坐标列表</span></span><br><span class="line">posList.append(pid.Point3D(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(<span class="number">300</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">posList.append(pid.Point3D(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">arrNodes.append(posList)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里使用凸度控制弧线，凸度=tan(圆心角)/4</span></span><br><span class="line">bList=pid.DoubleList()</span><br><span class="line"><span class="comment">#bList.fromList([1,1,0])</span></span><br><span class="line">bList.append(<span class="number">1</span>)</span><br><span class="line">bList.append(<span class="number">1</span>)</span><br><span class="line">bList.append(<span class="number">0</span>)</span><br><span class="line">arrBulges.append(bList)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取默认线编码，并创建实体</span></span><br><span class="line">geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOLYLINE)</span><br><span class="line">entity=pid.iDataPolygon(geoCode,arrNodes,arrBulges)</span><br><span class="line"></span><br><span class="line">pid.iDataAppendEntity(entity) <span class="comment">#实体提交到图面</span></span><br><span class="line">pid.CommitEntity(entity,pid.iData.kAppended)  <span class="comment">#实体提交到数据库</span></span><br><span class="line">pid.iDataRegen(<span class="keyword">None</span>,<span class="keyword">True</span>) <span class="comment">#刷新图面</span></span><br></pre></td></tr></table></figure>
<h4 id="实体属性"><a href="#实体属性" class="headerlink" title="实体属性"></a>实体属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">e,entity,point=pid.iDataEntSel(<span class="string">'Select an entity'</span>)</span><br><span class="line"><span class="keyword">if</span> e==pid.iData.eOk:</span><br><span class="line">  propertys=entity.getXDataAll()  <span class="comment">#实体所有扩展属性</span></span><br><span class="line">  bz=entity.getXData(<span class="string">'WYBZ'</span>)  <span class="comment">#取出特定扩展属性</span></span><br><span class="line">  <span class="keyword">if</span> bz.type()==pid.Variant.Type_Invalid:</span><br><span class="line">    print(<span class="string">'选中实体不存在WYBZ字段'</span>)</span><br><span class="line">  print(<span class="string">'原始值: '</span>+entity.getXData(<span class="string">'GD'</span>).toString())</span><br><span class="line">  bz_new=pid.Variant()</span><br><span class="line">  bz_new.setValue(<span class="string">'设置新值'</span>)</span><br><span class="line">  entity.setXData(<span class="string">'WYBZ'</span>,bz_new)  <span class="comment">#设置新值</span></span><br><span class="line">  print(<span class="string">'修改值: '</span>+entity.getXData(<span class="string">'GD'</span>).toString())</span><br><span class="line">  entity.setSelected(<span class="keyword">True</span>)  <span class="comment">#让选择的实体显示出来</span></span><br><span class="line">  pid.COmmitEntity(entity,pid.iData.kModified)  <span class="comment">#修改提交到数据库</span></span><br><span class="line">  pid.iDataRegen(<span class="keyword">None</span>,<span class="keyword">True</span>) <span class="comment">#刷新图面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  print(<span class="string">'The selected entity has &#123;&#125; propertys'</span>.format(len(propertys)))</span><br><span class="line">  <span class="keyword">for</span> k,v <span class="keyword">in</span> propertys:</span><br><span class="line">    print(k,<span class="string">': '</span>,v.toString())</span><br><span class="line">  p=propertys[<span class="string">'CODE'</span>]</span><br><span class="line">  print(p)</span><br><span class="line">  <span class="comment">#print(propertys['CODE'].toString()) #同样为取属性</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'esc'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>在iData中增删改了实体都需要提交才能生效，分别是提交到图面(按需调用iDataAppendEntity、iDataEntDel)、提交到数据库(调用Commit方法)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#点实体实例</span></span><br><span class="line">count=<span class="number">100</span></span><br><span class="line">entityList=pid.iDataEntityList()</span><br><span class="line">geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOINT)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> range(count):</span><br><span class="line">    pos=pid.Point3D(i*<span class="number">10</span>,j*<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">    point=pid.iDataPoint(geoCode,pos)</span><br><span class="line">    entityList.append(point)</span><br><span class="line"><span class="comment">#提交实体到图面</span></span><br><span class="line">err=pid.iDataAppendEntity(entityList)</span><br><span class="line"><span class="keyword">if</span> err==pid.iData.eOk:</span><br><span class="line">  print(<span class="string">'添加了&#123;&#125;个实体到屏幕'</span>.format(entityList.size()))</span><br><span class="line">err=pid.CommitEntity(entityList,pid.iData.kAppended)</span><br><span class="line"><span class="keyword">if</span> err==pid.iData.eOk:</span><br><span class="line">  print(<span class="string">'添加了&#123;&#125;个实体到数据库'</span>.format(entityList.size()))</span><br><span class="line">pid.iDataRegen(<span class="keyword">None</span>,<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#线实体实例</span></span><br><span class="line">arrNodes=pid.Point3DListList()</span><br><span class="line">arrBulges=pid.DoubleListList()</span><br><span class="line"></span><br><span class="line"><span class="comment">#曲线第一部分，绘制正弦曲线</span></span><br><span class="line">posList=pid.Point3DList()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">628</span>,<span class="number">2</span>):</span><br><span class="line">  y=<span class="number">100</span>*math.sin(i/<span class="number">100.0</span>)</span><br><span class="line">  pos=pid.Point3D(i,y,<span class="number">0</span>)</span><br><span class="line">  posList.append(pos)</span><br><span class="line">arrNodes.append(posList)</span><br><span class="line"></span><br><span class="line"><span class="comment">#曲线第一部分，绘制余弦曲线</span></span><br><span class="line">posList=pid.Point3DList()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">628</span>,<span class="number">2</span>):</span><br><span class="line">  y=<span class="number">100</span>*math.cos(i/<span class="number">100.0</span>)</span><br><span class="line">  pos=pid.Point3D(i,y,<span class="number">0</span>)</span><br><span class="line">  posList.append(pos)</span><br><span class="line">arrNodes.append(posList)</span><br><span class="line"></span><br><span class="line">geoCode=pid.getDeFaultGeoCode(pid.iData.IDATAPOLYLINE)</span><br><span class="line">entityList=pid.iDataPolyline(geoCode,arrNodes,arrBulges)</span><br><span class="line"></span><br><span class="line"><span class="comment">#提交实体到图面</span></span><br><span class="line">err=pid.iDataAppendEntity(entityList)</span><br><span class="line">err=pid.CommitEntity(entityList,pid.iData.kAppended)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加说明文字</span></span><br><span class="line">geoCode=pid.getDeFaultGeoCode(pid.iData.IDATATEXT)</span><br><span class="line">entity=pid.iDataText(geoCode,pid.Point3D(<span class="number">10</span>,<span class="number">-10</span>,<span class="number">0</span>),<span class="string">'y=sin(x)'</span>)  <span class="comment">#设置文字注记的位置</span></span><br><span class="line">entity.setFamily(<span class="string">'微软雅黑'</span>)  <span class="comment">#设置字体</span></span><br><span class="line">entity.setPointSizeF(<span class="number">18</span>*<span class="number">4.0654228942042955</span>) <span class="comment">#设置字高(需要乘以一个固定比例)</span></span><br><span class="line">entity.setItalic(<span class="keyword">True</span>)</span><br><span class="line">pid.iDataAppendEntity(entity)</span><br><span class="line">pid.CommitEntity(entity,pid.iData.kAppended)</span><br><span class="line"></span><br><span class="line">pid.iDataRegen(<span class="keyword">None</span>,<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/03/08/iData实体/" data-id="cjyzjijpp0007h8w1eah0ze39" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-mySQL安装小记" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/03/07/mySQL安装小记/">mySQL安装小记</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/03/07/mySQL安装小记/" class="article-date">
  <time datetime="2019-03-07T12:15:57.000Z" itemprop="datePublished">2019-03-07</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p>今天搭建了mySQL环境，想着准备学一下怎么用QT操作数据库，期间遇到了些小问题，现在来记录一下</p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><ul>
<li>首先我们先去<a href="https://www.mysql.com/cn/" target="_blank" rel="noopener">mySQL</a>官网下载对应的版本，这里我们选择<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">社区版</a>，然后选择一个路径把压缩包解压，在路径目录下新建一个my.ini配置文件，记事本打开后输入以下内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=C:\\web\\mysql-8.0.11</span><br><span class="line"># 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</span><br><span class="line"># datadir=C:\\web\\sqldata</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul>
<li><p>接下来，我们开始配置环境，管理员身份打开cmd，并切换到你刚才解压文件的路径下，按步骤执行以下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --console   #初始化数据库</span><br><span class="line"></span><br><span class="line">#命令执行完毕后，会输出root的初始密码</span><br><span class="line">2018-04-20T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: APWCY5ws&amp;hjQ</span><br><span class="line">#这里的APWCY5ws&amp;hjQ就是密码，之后的登录操作会用到</span><br><span class="line"></span><br><span class="line">mysqld install      #安装</span><br><span class="line">net start mysql     #启动服务</span><br><span class="line"></span><br><span class="line">mysql -h 主机名 -u 用户名 -p    #h为要登录的主机名，默认为localhost，可忽略；u为用户名；p为密码</span><br><span class="line">#输入命令后回车，会提示你输入密码，这时候就输入上面的默认root密码</span><br></pre></td></tr></table></figure>
</li>
<li><p>到这里还没有结束，需要修改默认的root密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter user &apos;用户名&apos;@&apos;主机名&apos; identified by &apos;新密码&apos;;   #要修改root密码，这里的主机名填localhost</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>到这里基本的配置就完毕了，mySQL有不少图形化窗口软件支持，例如<a href="https://www.navicat.com/en/" target="_blank" rel="noopener">Navicat</a>这里就不赘述了，结合需要去使用，注意，在条件允许的情况下，记得<font color="red">支持正版</font>哦~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://Wlka.github.io/2019/03/07/mySQL安装小记/" data-id="cjyzjijql000jh8w147b41fun" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
  </article>
  
  
    <nav class="page-nav">
      
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Olde posts</a>
    </nav>
  
</section>
</div>

  <footer class="footer">
  
  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2019 Wlka</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://zhwangart.github.io">zhwangart</a></li>
      <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
      <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
    </ul>
  </div>
</footer>
</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Wlka"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>


<!-- 
  <script src="/js/search.js"></script>
 -->


  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>